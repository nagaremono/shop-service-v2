# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateProduct {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
}

type AggregateSoldItem {
  _avg: SoldItemAvgAggregate
  _count: SoldItemCountAggregate
  _max: SoldItemMaxAggregate
  _min: SoldItemMinAggregate
  _sum: SoldItemSumAggregate
}

type AggregateTransaction {
  _avg: TransactionAvgAggregate
  _count: TransactionCountAggregate
  _max: TransactionMaxAggregate
  _min: TransactionMinAggregate
  _sum: TransactionSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

enum AuthMessage {
  CREDENTIALS_ACCEPTED
  INCORRECT_CREDENTIALS
  LOGGED_OUT
  NONEXISTENT_ACCOUNT
  UNAUTHORIZED
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalFieldUpdateOperationsInput {
  decrement: Decimal
  divide: Decimal
  increment: Decimal
  multiply: Decimal
  set: Decimal
}

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input DecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  equals: JSON
  not: JSON
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  equals: JSON
  not: JSON
}

type Mutation {
  createManyProduct(data: [ProductCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySoldItem(data: [SoldItemCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTransaction(data: [TransactionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createProduct(data: ProductCreateInput!): Product!
  createSoldItem(data: SoldItemCreateInput!): SoldItem!
  createTransaction(data: TransactionCreateInput!): Transaction!
  createUser(data: UserCreateInput!): User!
  deleteManyProduct(where: ProductWhereInput): AffectedRowsOutput!
  deleteManySoldItem(where: SoldItemWhereInput): AffectedRowsOutput!
  deleteManyTransaction(where: TransactionWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteSoldItem(where: SoldItemWhereUniqueInput!): SoldItem
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  deleteUser(where: UserWhereUniqueInput!): User
  login(email: String!, password: String!): AuthMessage!
  logout: AuthMessage!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): AffectedRowsOutput!
  updateManySoldItem(data: SoldItemUpdateManyMutationInput!, where: SoldItemWhereInput): AffectedRowsOutput!
  updateManyTransaction(data: TransactionUpdateManyMutationInput!, where: TransactionWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateSoldItem(data: SoldItemUpdateInput!, where: SoldItemWhereUniqueInput!): SoldItem
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertSoldItem(create: SoldItemCreateInput!, update: SoldItemUpdateInput!, where: SoldItemWhereUniqueInput!): SoldItem!
  upsertTransaction(create: TransactionCreateInput!, update: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedDecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  equals: JSON
  not: JSON
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Product {
  _count: ProductCount
  createdAt: DateTime!
  id: String!
  images: JSON!
  name: String!
  price: Decimal!
  soldItems(cursor: SoldItemWhereUniqueInput, distinct: [SoldItemScalarFieldEnum!], orderBy: [SoldItemOrderByWithRelationInput!], skip: Int, take: Int, where: SoldItemWhereInput): [SoldItem!]!
  stock: Int!
  updatedAt: DateTime!
}

type ProductAvgAggregate {
  price: Decimal
  stock: Float
}

input ProductAvgOrderByAggregateInput {
  price: SortOrder
  stock: SortOrder
}

type ProductCount {
  soldItems: Int!
}

type ProductCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  images: Int!
  name: Int!
  price: Int!
  stock: Int!
  updatedAt: Int!
}

input ProductCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  name: SortOrder
  price: SortOrder
  stock: SortOrder
  updatedAt: SortOrder
}

input ProductCreateInput {
  createdAt: DateTime
  id: String
  images: JSON
  name: String!
  price: Decimal!
  soldItems: SoldItemCreateNestedManyWithoutProductInput
  stock: Int!
  updatedAt: DateTime
}

input ProductCreateManyInput {
  createdAt: DateTime
  id: String
  images: JSON
  name: String!
  price: Decimal!
  stock: Int!
  updatedAt: DateTime
}

input ProductCreateNestedOneWithoutSoldItemsInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutSoldItemsInput
  create: ProductCreateWithoutSoldItemsInput
}

input ProductCreateOrConnectWithoutSoldItemsInput {
  create: ProductCreateWithoutSoldItemsInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutSoldItemsInput {
  createdAt: DateTime
  id: String
  images: JSON
  name: String!
  price: Decimal!
  stock: Int!
  updatedAt: DateTime
}

type ProductGroupBy {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
  createdAt: DateTime!
  id: String!
  images: JSON!
  name: String!
  price: Decimal!
  stock: Int!
  updatedAt: DateTime!
}

type ProductMaxAggregate {
  createdAt: DateTime
  id: String
  name: String
  price: Decimal
  stock: Int
  updatedAt: DateTime
}

input ProductMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  stock: SortOrder
  updatedAt: SortOrder
}

type ProductMinAggregate {
  createdAt: DateTime
  id: String
  name: String
  price: Decimal
  stock: Int
  updatedAt: DateTime
}

input ProductMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  stock: SortOrder
  updatedAt: SortOrder
}

input ProductOrderByWithAggregationInput {
  _avg: ProductAvgOrderByAggregateInput
  _count: ProductCountOrderByAggregateInput
  _max: ProductMaxOrderByAggregateInput
  _min: ProductMinOrderByAggregateInput
  _sum: ProductSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  name: SortOrder
  price: SortOrder
  stock: SortOrder
  updatedAt: SortOrder
}

input ProductOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  name: SortOrder
  price: SortOrder
  soldItems: SoldItemOrderByRelationAggregateInput
  stock: SortOrder
  updatedAt: SortOrder
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

enum ProductScalarFieldEnum {
  createdAt
  id
  images
  name
  price
  stock
  updatedAt
}

input ProductScalarWhereWithAggregatesInput {
  AND: [ProductScalarWhereWithAggregatesInput!]
  NOT: [ProductScalarWhereWithAggregatesInput!]
  OR: [ProductScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  images: JsonWithAggregatesFilter
  name: StringWithAggregatesFilter
  price: DecimalWithAggregatesFilter
  stock: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ProductSumAggregate {
  price: Decimal
  stock: Int
}

input ProductSumOrderByAggregateInput {
  price: SortOrder
  stock: SortOrder
}

input ProductUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  images: JSON
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  soldItems: SoldItemUpdateManyWithoutProductInput
  stock: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProductUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  images: JSON
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProductUpdateOneRequiredWithoutSoldItemsInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutSoldItemsInput
  create: ProductCreateWithoutSoldItemsInput
  update: ProductUpdateWithoutSoldItemsInput
  upsert: ProductUpsertWithoutSoldItemsInput
}

input ProductUpdateWithoutSoldItemsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  images: JSON
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProductUpsertWithoutSoldItemsInput {
  create: ProductCreateWithoutSoldItemsInput!
  update: ProductUpdateWithoutSoldItemsInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  images: JsonFilter
  name: StringFilter
  price: DecimalFilter
  soldItems: SoldItemListRelationFilter
  stock: IntFilter
  updatedAt: DateTimeFilter
}

input ProductWhereUniqueInput {
  id: String
}

type Query {
  aggregateProduct(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct!
  aggregateSoldItem(cursor: SoldItemWhereUniqueInput, orderBy: [SoldItemOrderByWithRelationInput!], skip: Int, take: Int, where: SoldItemWhereInput): AggregateSoldItem!
  aggregateTransaction(cursor: TransactionWhereUniqueInput, orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): AggregateTransaction!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstSoldItem(cursor: SoldItemWhereUniqueInput, distinct: [SoldItemScalarFieldEnum!], orderBy: [SoldItemOrderByWithRelationInput!], skip: Int, take: Int, where: SoldItemWhereInput): SoldItem
  findFirstTransaction(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): Transaction
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByProduct(by: [ProductScalarFieldEnum!]!, having: ProductScalarWhereWithAggregatesInput, orderBy: [ProductOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductWhereInput): [ProductGroupBy!]!
  groupBySoldItem(by: [SoldItemScalarFieldEnum!]!, having: SoldItemScalarWhereWithAggregatesInput, orderBy: [SoldItemOrderByWithAggregationInput!], skip: Int, take: Int, where: SoldItemWhereInput): [SoldItemGroupBy!]!
  groupByTransaction(by: [TransactionScalarFieldEnum!]!, having: TransactionScalarWhereWithAggregatesInput, orderBy: [TransactionOrderByWithAggregationInput!], skip: Int, take: Int, where: TransactionWhereInput): [TransactionGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  product(where: ProductWhereUniqueInput!): Product
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  soldItem(where: SoldItemWhereUniqueInput!): SoldItem
  soldItems(cursor: SoldItemWhereUniqueInput, distinct: [SoldItemScalarFieldEnum!], orderBy: [SoldItemOrderByWithRelationInput!], skip: Int, take: Int, where: SoldItemWhereInput): [SoldItem!]!
  testauth: String!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): [Transaction!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type SoldItem {
  createdAt: DateTime!
  id: Int!
  images: JSON!
  name: String!
  price: Decimal!
  product: Product!
  productId: String!
  quantity: Int!
  transaction: Transaction!
  transactionId: String!
  updatedAt: DateTime!
}

type SoldItemAvgAggregate {
  id: Float
  price: Decimal
  quantity: Float
}

input SoldItemAvgOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
  quantity: SortOrder
}

type SoldItemCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  images: Int!
  name: Int!
  price: Int!
  productId: Int!
  quantity: Int!
  transactionId: Int!
  updatedAt: Int!
}

input SoldItemCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  name: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  transactionId: SortOrder
  updatedAt: SortOrder
}

input SoldItemCreateInput {
  createdAt: DateTime
  images: JSON
  name: String!
  price: Decimal!
  product: ProductCreateNestedOneWithoutSoldItemsInput!
  quantity: Int!
  transaction: TransactionCreateNestedOneWithoutSoldItemsInput!
  updatedAt: DateTime
}

input SoldItemCreateManyInput {
  createdAt: DateTime
  id: Int
  images: JSON
  name: String!
  price: Decimal!
  productId: String!
  quantity: Int!
  transactionId: String!
  updatedAt: DateTime
}

input SoldItemCreateManyProductInput {
  createdAt: DateTime
  id: Int
  images: JSON
  name: String!
  price: Decimal!
  quantity: Int!
  transactionId: String!
  updatedAt: DateTime
}

input SoldItemCreateManyProductInputEnvelope {
  data: [SoldItemCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input SoldItemCreateManyTransactionInput {
  createdAt: DateTime
  id: Int
  images: JSON
  name: String!
  price: Decimal!
  productId: String!
  quantity: Int!
  updatedAt: DateTime
}

input SoldItemCreateManyTransactionInputEnvelope {
  data: [SoldItemCreateManyTransactionInput!]!
  skipDuplicates: Boolean
}

input SoldItemCreateNestedManyWithoutProductInput {
  connect: [SoldItemWhereUniqueInput!]
  connectOrCreate: [SoldItemCreateOrConnectWithoutProductInput!]
  create: [SoldItemCreateWithoutProductInput!]
  createMany: SoldItemCreateManyProductInputEnvelope
}

input SoldItemCreateNestedManyWithoutTransactionInput {
  connect: [SoldItemWhereUniqueInput!]
  connectOrCreate: [SoldItemCreateOrConnectWithoutTransactionInput!]
  create: [SoldItemCreateWithoutTransactionInput!]
  createMany: SoldItemCreateManyTransactionInputEnvelope
}

input SoldItemCreateOrConnectWithoutProductInput {
  create: SoldItemCreateWithoutProductInput!
  where: SoldItemWhereUniqueInput!
}

input SoldItemCreateOrConnectWithoutTransactionInput {
  create: SoldItemCreateWithoutTransactionInput!
  where: SoldItemWhereUniqueInput!
}

input SoldItemCreateWithoutProductInput {
  createdAt: DateTime
  images: JSON
  name: String!
  price: Decimal!
  quantity: Int!
  transaction: TransactionCreateNestedOneWithoutSoldItemsInput!
  updatedAt: DateTime
}

input SoldItemCreateWithoutTransactionInput {
  createdAt: DateTime
  images: JSON
  name: String!
  price: Decimal!
  product: ProductCreateNestedOneWithoutSoldItemsInput!
  quantity: Int!
  updatedAt: DateTime
}

type SoldItemGroupBy {
  _avg: SoldItemAvgAggregate
  _count: SoldItemCountAggregate
  _max: SoldItemMaxAggregate
  _min: SoldItemMinAggregate
  _sum: SoldItemSumAggregate
  createdAt: DateTime!
  id: Int!
  images: JSON!
  name: String!
  price: Decimal!
  productId: String!
  quantity: Int!
  transactionId: String!
  updatedAt: DateTime!
}

input SoldItemListRelationFilter {
  every: SoldItemWhereInput
  none: SoldItemWhereInput
  some: SoldItemWhereInput
}

type SoldItemMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  price: Decimal
  productId: String
  quantity: Int
  transactionId: String
  updatedAt: DateTime
}

input SoldItemMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  transactionId: SortOrder
  updatedAt: SortOrder
}

type SoldItemMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  price: Decimal
  productId: String
  quantity: Int
  transactionId: String
  updatedAt: DateTime
}

input SoldItemMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  transactionId: SortOrder
  updatedAt: SortOrder
}

input SoldItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input SoldItemOrderByWithAggregationInput {
  _avg: SoldItemAvgOrderByAggregateInput
  _count: SoldItemCountOrderByAggregateInput
  _max: SoldItemMaxOrderByAggregateInput
  _min: SoldItemMinOrderByAggregateInput
  _sum: SoldItemSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  name: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  transactionId: SortOrder
  updatedAt: SortOrder
}

input SoldItemOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  name: SortOrder
  price: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  transaction: TransactionOrderByWithRelationInput
  transactionId: SortOrder
  updatedAt: SortOrder
}

enum SoldItemScalarFieldEnum {
  createdAt
  id
  images
  name
  price
  productId
  quantity
  transactionId
  updatedAt
}

input SoldItemScalarWhereInput {
  AND: [SoldItemScalarWhereInput!]
  NOT: [SoldItemScalarWhereInput!]
  OR: [SoldItemScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  images: JsonFilter
  name: StringFilter
  price: DecimalFilter
  productId: StringFilter
  quantity: IntFilter
  transactionId: StringFilter
  updatedAt: DateTimeFilter
}

input SoldItemScalarWhereWithAggregatesInput {
  AND: [SoldItemScalarWhereWithAggregatesInput!]
  NOT: [SoldItemScalarWhereWithAggregatesInput!]
  OR: [SoldItemScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  images: JsonWithAggregatesFilter
  name: StringWithAggregatesFilter
  price: DecimalWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  transactionId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SoldItemSumAggregate {
  id: Int
  price: Decimal
  quantity: Int
}

input SoldItemSumOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
  quantity: SortOrder
}

input SoldItemUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  images: JSON
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutSoldItemsInput
  quantity: IntFieldUpdateOperationsInput
  transaction: TransactionUpdateOneRequiredWithoutSoldItemsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SoldItemUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  images: JSON
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SoldItemUpdateManyWithWhereWithoutProductInput {
  data: SoldItemUpdateManyMutationInput!
  where: SoldItemScalarWhereInput!
}

input SoldItemUpdateManyWithWhereWithoutTransactionInput {
  data: SoldItemUpdateManyMutationInput!
  where: SoldItemScalarWhereInput!
}

input SoldItemUpdateManyWithoutProductInput {
  connect: [SoldItemWhereUniqueInput!]
  connectOrCreate: [SoldItemCreateOrConnectWithoutProductInput!]
  create: [SoldItemCreateWithoutProductInput!]
  createMany: SoldItemCreateManyProductInputEnvelope
  delete: [SoldItemWhereUniqueInput!]
  deleteMany: [SoldItemScalarWhereInput!]
  disconnect: [SoldItemWhereUniqueInput!]
  set: [SoldItemWhereUniqueInput!]
  update: [SoldItemUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [SoldItemUpdateManyWithWhereWithoutProductInput!]
  upsert: [SoldItemUpsertWithWhereUniqueWithoutProductInput!]
}

input SoldItemUpdateManyWithoutTransactionInput {
  connect: [SoldItemWhereUniqueInput!]
  connectOrCreate: [SoldItemCreateOrConnectWithoutTransactionInput!]
  create: [SoldItemCreateWithoutTransactionInput!]
  createMany: SoldItemCreateManyTransactionInputEnvelope
  delete: [SoldItemWhereUniqueInput!]
  deleteMany: [SoldItemScalarWhereInput!]
  disconnect: [SoldItemWhereUniqueInput!]
  set: [SoldItemWhereUniqueInput!]
  update: [SoldItemUpdateWithWhereUniqueWithoutTransactionInput!]
  updateMany: [SoldItemUpdateManyWithWhereWithoutTransactionInput!]
  upsert: [SoldItemUpsertWithWhereUniqueWithoutTransactionInput!]
}

input SoldItemUpdateWithWhereUniqueWithoutProductInput {
  data: SoldItemUpdateWithoutProductInput!
  where: SoldItemWhereUniqueInput!
}

input SoldItemUpdateWithWhereUniqueWithoutTransactionInput {
  data: SoldItemUpdateWithoutTransactionInput!
  where: SoldItemWhereUniqueInput!
}

input SoldItemUpdateWithoutProductInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  images: JSON
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  transaction: TransactionUpdateOneRequiredWithoutSoldItemsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SoldItemUpdateWithoutTransactionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  images: JSON
  name: StringFieldUpdateOperationsInput
  price: DecimalFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutSoldItemsInput
  quantity: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SoldItemUpsertWithWhereUniqueWithoutProductInput {
  create: SoldItemCreateWithoutProductInput!
  update: SoldItemUpdateWithoutProductInput!
  where: SoldItemWhereUniqueInput!
}

input SoldItemUpsertWithWhereUniqueWithoutTransactionInput {
  create: SoldItemCreateWithoutTransactionInput!
  update: SoldItemUpdateWithoutTransactionInput!
  where: SoldItemWhereUniqueInput!
}

input SoldItemWhereInput {
  AND: [SoldItemWhereInput!]
  NOT: [SoldItemWhereInput!]
  OR: [SoldItemWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  images: JsonFilter
  name: StringFilter
  price: DecimalFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  transaction: TransactionRelationFilter
  transactionId: StringFilter
  updatedAt: DateTimeFilter
}

input SoldItemWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Transaction {
  _count: TransactionCount
  createdAt: DateTime!
  customer: User!
  customerid: Int!
  id: String!
  paymentStatus: String!
  soldItems(cursor: SoldItemWhereUniqueInput, distinct: [SoldItemScalarFieldEnum!], orderBy: [SoldItemOrderByWithRelationInput!], skip: Int, take: Int, where: SoldItemWhereInput): [SoldItem!]!
  totalAmount: Decimal!
  updatedAt: DateTime!
}

type TransactionAvgAggregate {
  customerid: Float
  totalAmount: Decimal
}

input TransactionAvgOrderByAggregateInput {
  customerid: SortOrder
  totalAmount: SortOrder
}

type TransactionCount {
  soldItems: Int!
}

type TransactionCountAggregate {
  _all: Int!
  createdAt: Int!
  customerid: Int!
  id: Int!
  paymentStatus: Int!
  totalAmount: Int!
  updatedAt: Int!
}

input TransactionCountOrderByAggregateInput {
  createdAt: SortOrder
  customerid: SortOrder
  id: SortOrder
  paymentStatus: SortOrder
  totalAmount: SortOrder
  updatedAt: SortOrder
}

input TransactionCreateInput {
  createdAt: DateTime
  customer: UserCreateNestedOneWithoutPurchasesInput!
  id: String
  paymentStatus: String!
  soldItems: SoldItemCreateNestedManyWithoutTransactionInput
  totalAmount: Decimal!
  updatedAt: DateTime
}

input TransactionCreateManyCustomerInput {
  createdAt: DateTime
  id: String
  paymentStatus: String!
  totalAmount: Decimal!
  updatedAt: DateTime
}

input TransactionCreateManyCustomerInputEnvelope {
  data: [TransactionCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input TransactionCreateManyInput {
  createdAt: DateTime
  customerid: Int!
  id: String
  paymentStatus: String!
  totalAmount: Decimal!
  updatedAt: DateTime
}

input TransactionCreateNestedManyWithoutCustomerInput {
  connect: [TransactionWhereUniqueInput!]
  connectOrCreate: [TransactionCreateOrConnectWithoutCustomerInput!]
  create: [TransactionCreateWithoutCustomerInput!]
  createMany: TransactionCreateManyCustomerInputEnvelope
}

input TransactionCreateNestedOneWithoutSoldItemsInput {
  connect: TransactionWhereUniqueInput
  connectOrCreate: TransactionCreateOrConnectWithoutSoldItemsInput
  create: TransactionCreateWithoutSoldItemsInput
}

input TransactionCreateOrConnectWithoutCustomerInput {
  create: TransactionCreateWithoutCustomerInput!
  where: TransactionWhereUniqueInput!
}

input TransactionCreateOrConnectWithoutSoldItemsInput {
  create: TransactionCreateWithoutSoldItemsInput!
  where: TransactionWhereUniqueInput!
}

input TransactionCreateWithoutCustomerInput {
  createdAt: DateTime
  id: String
  paymentStatus: String!
  soldItems: SoldItemCreateNestedManyWithoutTransactionInput
  totalAmount: Decimal!
  updatedAt: DateTime
}

input TransactionCreateWithoutSoldItemsInput {
  createdAt: DateTime
  customer: UserCreateNestedOneWithoutPurchasesInput!
  id: String
  paymentStatus: String!
  totalAmount: Decimal!
  updatedAt: DateTime
}

type TransactionGroupBy {
  _avg: TransactionAvgAggregate
  _count: TransactionCountAggregate
  _max: TransactionMaxAggregate
  _min: TransactionMinAggregate
  _sum: TransactionSumAggregate
  createdAt: DateTime!
  customerid: Int!
  id: String!
  paymentStatus: String!
  totalAmount: Decimal!
  updatedAt: DateTime!
}

input TransactionListRelationFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

type TransactionMaxAggregate {
  createdAt: DateTime
  customerid: Int
  id: String
  paymentStatus: String
  totalAmount: Decimal
  updatedAt: DateTime
}

input TransactionMaxOrderByAggregateInput {
  createdAt: SortOrder
  customerid: SortOrder
  id: SortOrder
  paymentStatus: SortOrder
  totalAmount: SortOrder
  updatedAt: SortOrder
}

type TransactionMinAggregate {
  createdAt: DateTime
  customerid: Int
  id: String
  paymentStatus: String
  totalAmount: Decimal
  updatedAt: DateTime
}

input TransactionMinOrderByAggregateInput {
  createdAt: SortOrder
  customerid: SortOrder
  id: SortOrder
  paymentStatus: SortOrder
  totalAmount: SortOrder
  updatedAt: SortOrder
}

input TransactionOrderByRelationAggregateInput {
  _count: SortOrder
}

input TransactionOrderByWithAggregationInput {
  _avg: TransactionAvgOrderByAggregateInput
  _count: TransactionCountOrderByAggregateInput
  _max: TransactionMaxOrderByAggregateInput
  _min: TransactionMinOrderByAggregateInput
  _sum: TransactionSumOrderByAggregateInput
  createdAt: SortOrder
  customerid: SortOrder
  id: SortOrder
  paymentStatus: SortOrder
  totalAmount: SortOrder
  updatedAt: SortOrder
}

input TransactionOrderByWithRelationInput {
  createdAt: SortOrder
  customer: UserOrderByWithRelationInput
  customerid: SortOrder
  id: SortOrder
  paymentStatus: SortOrder
  soldItems: SoldItemOrderByRelationAggregateInput
  totalAmount: SortOrder
  updatedAt: SortOrder
}

input TransactionRelationFilter {
  is: TransactionWhereInput
  isNot: TransactionWhereInput
}

enum TransactionScalarFieldEnum {
  createdAt
  customerid
  id
  paymentStatus
  totalAmount
  updatedAt
}

input TransactionScalarWhereInput {
  AND: [TransactionScalarWhereInput!]
  NOT: [TransactionScalarWhereInput!]
  OR: [TransactionScalarWhereInput!]
  createdAt: DateTimeFilter
  customerid: IntFilter
  id: StringFilter
  paymentStatus: StringFilter
  totalAmount: DecimalFilter
  updatedAt: DateTimeFilter
}

input TransactionScalarWhereWithAggregatesInput {
  AND: [TransactionScalarWhereWithAggregatesInput!]
  NOT: [TransactionScalarWhereWithAggregatesInput!]
  OR: [TransactionScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  customerid: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  paymentStatus: StringWithAggregatesFilter
  totalAmount: DecimalWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type TransactionSumAggregate {
  customerid: Int
  totalAmount: Decimal
}

input TransactionSumOrderByAggregateInput {
  customerid: SortOrder
  totalAmount: SortOrder
}

input TransactionUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: UserUpdateOneRequiredWithoutPurchasesInput
  id: StringFieldUpdateOperationsInput
  paymentStatus: StringFieldUpdateOperationsInput
  soldItems: SoldItemUpdateManyWithoutTransactionInput
  totalAmount: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  paymentStatus: StringFieldUpdateOperationsInput
  totalAmount: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionUpdateManyWithWhereWithoutCustomerInput {
  data: TransactionUpdateManyMutationInput!
  where: TransactionScalarWhereInput!
}

input TransactionUpdateManyWithoutCustomerInput {
  connect: [TransactionWhereUniqueInput!]
  connectOrCreate: [TransactionCreateOrConnectWithoutCustomerInput!]
  create: [TransactionCreateWithoutCustomerInput!]
  createMany: TransactionCreateManyCustomerInputEnvelope
  delete: [TransactionWhereUniqueInput!]
  deleteMany: [TransactionScalarWhereInput!]
  disconnect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [TransactionUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutCustomerInput!]
}

input TransactionUpdateOneRequiredWithoutSoldItemsInput {
  connect: TransactionWhereUniqueInput
  connectOrCreate: TransactionCreateOrConnectWithoutSoldItemsInput
  create: TransactionCreateWithoutSoldItemsInput
  update: TransactionUpdateWithoutSoldItemsInput
  upsert: TransactionUpsertWithoutSoldItemsInput
}

input TransactionUpdateWithWhereUniqueWithoutCustomerInput {
  data: TransactionUpdateWithoutCustomerInput!
  where: TransactionWhereUniqueInput!
}

input TransactionUpdateWithoutCustomerInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  paymentStatus: StringFieldUpdateOperationsInput
  soldItems: SoldItemUpdateManyWithoutTransactionInput
  totalAmount: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionUpdateWithoutSoldItemsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: UserUpdateOneRequiredWithoutPurchasesInput
  id: StringFieldUpdateOperationsInput
  paymentStatus: StringFieldUpdateOperationsInput
  totalAmount: DecimalFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TransactionUpsertWithWhereUniqueWithoutCustomerInput {
  create: TransactionCreateWithoutCustomerInput!
  update: TransactionUpdateWithoutCustomerInput!
  where: TransactionWhereUniqueInput!
}

input TransactionUpsertWithoutSoldItemsInput {
  create: TransactionCreateWithoutSoldItemsInput!
  update: TransactionUpdateWithoutSoldItemsInput!
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  createdAt: DateTimeFilter
  customer: UserRelationFilter
  customerid: IntFilter
  id: StringFilter
  paymentStatus: StringFilter
  soldItems: SoldItemListRelationFilter
  totalAmount: DecimalFilter
  updatedAt: DateTimeFilter
}

input TransactionWhereUniqueInput {
  id: String
}

type User {
  _count: UserCount
  createdAt: DateTime!
  email: String!
  id: Int!
  password: String!
  purchases(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): [Transaction!]!
  updatedAt: DateTime!
  username: String!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  purchases: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  password: Int!
  updatedAt: Int!
  username: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  password: String!
  purchases: TransactionCreateNestedManyWithoutCustomerInput
  updatedAt: DateTime
  username: String!
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  id: Int
  password: String!
  updatedAt: DateTime
  username: String!
}

input UserCreateNestedOneWithoutPurchasesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPurchasesInput
  create: UserCreateWithoutPurchasesInput
}

input UserCreateOrConnectWithoutPurchasesInput {
  create: UserCreateWithoutPurchasesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutPurchasesInput {
  createdAt: DateTime
  email: String!
  password: String!
  updatedAt: DateTime
  username: String!
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: DateTime!
  email: String!
  id: Int!
  password: String!
  updatedAt: DateTime!
  username: String!
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: Int
  password: String
  updatedAt: DateTime
  username: String
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: Int
  password: String
  updatedAt: DateTime
  username: String
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  purchases: TransactionOrderByRelationAggregateInput
  updatedAt: SortOrder
  username: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  password
  updatedAt
  username
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  password: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  purchases: TransactionUpdateManyWithoutCustomerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutPurchasesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPurchasesInput
  create: UserCreateWithoutPurchasesInput
  update: UserUpdateWithoutPurchasesInput
  upsert: UserUpsertWithoutPurchasesInput
}

input UserUpdateWithoutPurchasesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutPurchasesInput {
  create: UserCreateWithoutPurchasesInput!
  update: UserUpdateWithoutPurchasesInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  password: StringFilter
  purchases: TransactionListRelationFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}
